package graph

import (
	"fmt"
	"strings"

	"github.com/aws/symphony/api/v1alpha1"
	"k8s.io/apimachinery/pkg/runtime"
	"sigs.k8s.io/yaml"
)

// This package is reponsible of parsing the Construct field spec and building the Resource Graph.
// It uses the spec.resources field to understand the relationships between resources.
// One of the main challenges is that resources could be of any types, and the relationships between them
// is described using CEL expressions.

// The Construct node is root of the Resource Graph.
// Other resources can easily consume any spec/metadata/labels/annotations from the Construct node.
// The construct node is provided by the user, and it is not created by the controller.

// Other resources are called "children" of the Construct node.
// They can consume data from the Construct node, and they can also consume data from other children.
// There two situations where a child can consume data from another child:
// 1. The child is consuming a spec field from another child.
// 2. The child is consuming a status field another child.

type Collection struct {
	Construct *Resource
	Resources   map[string]*Resource
}

type Resource struct {
	Data               map[string]interface{}
	DependentResources []string
}

type Builder struct{}

func (b *Builder) Build(rawConstruct runtime.RawExtension, resources []*v1alpha1.Resource) (*Collection, error) {
	// Start by walking through the resources and build a map of resources.
	// This map will be used to quickly access a resource by its name.
	resourceMap := make(map[string]*Resource)
	for _, resource := range resources {
		var data map[string]interface{}
		err := yaml.Unmarshal(resource.Definition.Raw, &data)
		if err != nil {
			return nil, fmt.Errorf("couldn't parse yaml data from resource %s: %v", resource.Name, err)
		}
		// Now we need to walk throught the definition of the resource and find all the CEL expressions.
		// We need to find all the expressions that are consuming data from other resources.

		// We recursively walk through the data and find all the CEL expressions while keeping track of the
		// of the path to the expression.
		// For example, if we have the following data:
		//
		// spec:
		//  replicas: $spec.replicas
		//  containers:
		//   - name: $resource-1.containerName
		//
		// We want to return a map with the following key/value:
		// "spec.replicas": "$spec.replicas"
		// "spec.containers[0].name": "$resource-1.containerName"
		//
		// Later on, we will use this map to find the dependencies between resources.
		// And leverage CEL to evaluate the expressions and replace them with the actual values.
		// We also need to validate that the types are matching.
		//
		// Thoughts about returning functions instead of strings to manipulate the data.
		//
		// If we find something

		relationshipsMap, err := findRelationships("", data, resourceMap)
		if err != nil {
			return nil, fmt.Errorf("couldn't find relationships for resource %s: %v", resource.Name, err)
		}
		_ = relationshipsMap

		resourceMap[resource.Name] = &Resource{
			Data:               data,
			DependentResources: make([]string, 0),
		}
	}
	collection := &Collection{
		Resources: resourceMap,
	}

	return collection, nil
}

func isCELExpression(expression string) bool {
	return strings.HasPrefix(expression, "$")
}

func isValidReference(reference string, resourceMap map[string]*Resource) bool {
	if !strings.HasPrefix(reference, "$") {
		return false
	}
	trimed := strings.TrimPrefix(reference, "$")
	parts := strings.Split(trimed, ".")
	if len(parts) < 2 {
		return false
	}
	resourceName := parts[0]
	_, ok := resourceMap[resourceName]
	if !ok {
		return resourceName == "spec" || resourceName == "status"
	}
	return true
}

func findRelationships(prependPath string, data map[string]interface{}, resourceMap map[string]*Resource) (map[string]string, error) {
	relationshipsMap := make(map[string]string)
	for key, value := range data {
		switch v := value.(type) {
		case map[string]interface{}:
			rss, err := findRelationships(prependPath+"."+key, v, resourceMap)
			if err != nil {
				return nil, err
			}
			mergeMaps(relationshipsMap, rss)
		case []interface{}:
			for i, item := range v {
				switch itemType := item.(type) {
				case map[string]interface{}:
					rss, err := findRelationships(fmt.Sprintf("%s.%s[%d]", prependPath, key, i), item.(map[string]interface{}), resourceMap)
					if err != nil {
						return nil, err
					}
					mergeMaps(relationshipsMap, rss)
				case string:
					if isCELExpression(itemType) {
						relationshipsMap[prependPath+"."+key] = itemType
					}
				default:
					// We don't have arrays of arrays, so we don't need to do anything here.
				}
			}
		case string:
			if isCELExpression(v) {
				relationshipsMap[prependPath+"."+key] = v
			}
		default:
			// Anything else is either a bool, int, float, etc.
			// We don't need to do anything with it.
		}
	}
	return relationshipsMap, nil
}

func mergeMaps(maps ...map[string]string) map[string]string {
	result := make(map[string]string)
	for _, m := range maps {
		for k, v := range m {
			result[k] = v
		}
	}
	return result
}
